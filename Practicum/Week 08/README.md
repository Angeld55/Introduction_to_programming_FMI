# УП - Практикум 26.11.2025 Седмица 8

**Задача 1:** Да се напише функиця, която приема n-цифрено число и проверява дали цифрите, които го съставят не се повтарят.

**Пример:**

Вход:
```c++
1234
```
Изход:
```c++
True
```


Вход:
```c++
5665
```
Изход:
```c++
False
```

**Задача 2:** Напишете функция, която приема число в десетична бройна система и проверява дали същото число е плаиндром в двоична бройна система.

**Пример:**

Вход: 
```c++
9
```
Изход: 
```c++
True // 9 -> 1001
```

Вход: 
```c++
10
```
Изход: 
```c++
False // 10 -> 1010
```

**Задача 3:** Да се напише функция, която приема естествено число n и генерира първите n числа от редицата на фибоначи. 

**Пример:**

Вход:
```c++
9
```
Изход:
```c++
0, 1, 1, 2, 3, 5, 8, 13, 21
```

**Задача 4:** Да се напише функция, която приема две естествени числа в десетична бройна система, обръща ги в двоична бройа система и генерира двоично число, което е резултат от прилагането на операцията XOR над двете въведени числа.

**Пример:**

Вход:
```c++
5 9 // 5 -> 0101, 9 -> 1001
```
Изход:
```c++
1100
```

**Задача 5:** Да се напише функция, която приема естествено число N и го преобразува в двоичен низ. Низът се разделя на две половини(ако име нечетна дължина, то първата половина да е с 1 по-дълга), които се разменят и се конкатенират наново (т.е 1101 -> 0111). Ако полученото число е палиндром, то да се събере с единица. Резулатът да се преобразува обратно в десетична бройна система и да се запише в масив. Операцията се повтаря N на брой пъти.

**Пример:**

Вход:
```c++
5
```
Изход:
```c++
6, 3, 4, 2, 2
```

**Задача 6:**
Да се напише функция, която приема масив и намира най-голямата сума на два негови елемента. Функцията да връща индексите на елементите, образуващи тази сума както и самата сума. 

**Пример :**

Вход:
```c++
[3, 8, 2, 7, 5]
```
Изход:
```c++
1, 3, 15
```

`

**Задача 7:** От даден масив от сортирани последователни числа са премахнати някои числа. Напишете функция, която приема такъв масив и връща най-малкото премахнато число.
Решението трябва да работи с *логаритмична сложност* (а не с линейно минаване през масива).

**Пример 1:**
Вход:
```c++
[5, 6, 7, 9, 10, 12, 13]
```

Изход:
```c++
8 // премахнатите числа са 8 и 11
```

**Пример 2:**
Вход:
```c++
[10, 12, 13, 14, 16]
```

Изход:
```c++
11 // премахнатите числа са 11 и 16
```

**Задача 8:** Проверка за *специално* число

Числото n (в десетична бройна система) е *специално*, ако когато го напишем в обратен ред и го добавим към оригинала, получаваме палиндром. Ако не е, повтаряме операцията (обръщане + събиране) k на брой пъти.
Да се напише функция, която връща на коя итерация се появява палиндром (или -1, ако не се появи такова). 

**Пример:**

Вход:
```c++
n = 87
k = 5
```

Изход:
```c++
4
```

*Ход на изпълнение:*
1. 87 + 78 = 165 -> не е палиндром
2. 165 + 561 = 726 -> не е палиндром
3. 726 + 627 = 1353 -> не е палиндром
4. 1353 + 3531 = 4884 -> палиндром

**Задача 9:** Сортиране на масив от числа.
Даден е масив с n на брой числа (0 <= n <= 1024).
Да се напише функция, която сортира този масив и го принтира.

**Пример:**

Вход:
```c++
[15, 4, 6, 0, 32, 12]
```

Изход:
```c++
[0, 4, 6, 12, 15, 32]
```


**Задача 10**  Намиране на "магични числа"
Даден е масив от n на брой цели числа (0 <= n <= 1024).
Някои числа в него се държат "магично" - число *x* е магично, ако сумата на цифрите на *x* дели произведението на цифрите на *x* без остатък (и произведението != 0).
Да се напише функция, която филтрира масива и връща масив от уникалните магични числа, подредени нарастващо.

**Пример 1:**

Вход:
```c++
[12, 22, 13, 12, 111, 24, 36]
```

Изход:
```c++
[22, 36]
```

**Пример 2:**

Вход:
```c++
[10, 12, 111, 25]
```

Изход:
```c++
[]
```
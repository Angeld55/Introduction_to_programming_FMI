
## Задачи 
### Задачи са търсене

**1.** Да се напише функция, която приема число и матрица, чиито редове и колони са сортирани в растящ ред. Функцията да връща индексите на реда и колоната, на която се намира числото (реализира се чрез двоично търсене).

**Пример:**

Вход:
```c++
7
1 2 3 
4 5 6
7 8 9
```
Изход:
```c++
2 0
```

**2.** Да се напише функция, която приема сортиран масив   от цели числа (в който може да има повторения) и цяло число и връща индекса, на който трябва да се вмъкне числото.

**Пример:**

Вход:
```c++
1 2 5 6 7 8 9
4
```

Изход:
```c++
2
```

**3.** Дадени са два масива:  **X**  (с n елемента) и  **Y**  (с n+1 елемента). **X**  е съставен само от УНИКАЛНИ положителни цели числа. **Y**  се получава от X чрез едно  **"вмъкване"**  на числото -1 на някоя позиция. Да се напише функция, която приема тези 2 масива и връща индекса на вмъкнатата -1 (реализира се чрез двоично търсене).


**Пример:**

Вход:
```c++
X = [5, 2, 9, 1]
Y = [5, -1, 2, 9 , 1]
```
Изход:
```c++
1
```

**4.** Даден е масив от цели числа, който представлява планина с един единствен връх. Това означава, че съществува такъв индекс **i**,  т.ч. 
arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Да се напише функция, която приема масива и връща индекса **i**.

**Пример:**

Вход:
```c++
[39, 4, 6, 1, 2, 66, 33]
40
```
Изход:
```c++
4
```

### Задачи за сортиране

**5.** Да се реализира сортировката **Cocktail shaker**. Алгоритъмът е следният: сравняваме първите 2 елемента и ако първият е по-голям, ги разменяме. Същото се изпълнява, докато не стигнем до края на колекцията. След това сравняваме предпоследния и предпредпоследния и ако предпоследният е по-малък, ги разменяме. Същото се изпълнява, докато не стигнем до началото на колекцията. След това  сравняваме втория и третия елемент и т.н. Процедурата се повтаря в двете посоки, докато масивът не е сортиран. 
Да се анализира алгоритъмът (сложност и стабилност).

**Пример:**
**7** **6** 4 9 5 -> **6** **7** 4 9 5 -> 6 **4** **7** 9 5 -> 
6 4 **7** **9** 5 -> 6 4 7 **5** **9** -> 
6 4 **5** **7** 9 ->  6 **4** **5** 7 9 -> **4** **6** 5 7 9 ->
4 **5** **6** 7 9 

**6.** Да се напише функция, която приема масив от цели неотрицателни числа и връща първото липсващо число.

**Пример:**

Вход:
```c++
0 6 3 2 1
```

Изход:
```c++
4
```

**7.** Да се напише функция, която приема масив от неповтарящи се цели числа и цяло число **k** и връща **k**-тия по големина елемент (не е нужно да се сортира целия масив).

**Пример:**

Вход:
```c++
[39, 4, 6, 1, 2, 66, 33]
3
```
Изход:
```c++
33
```

**8.** Даден е масив от цели числа (без повторение) - цени на бонбони. Разполагаме с **k** лева. Да се напише функция, която приема масива и **k** и връща колко най-много бонбона можем да закупим.

**Пример:**

Вход:
```c++
[39, 4, 6, 1, 2, 66, 33]
40
```
Изход:
```c++
4
```

**9.** Да се напише функция, която приема масив от цели числа и го сортира така, че в лявата част да са четните числа, сортирани в нарастващ ред, а в дясната - нечетните в намаляващ.

**Пример:**

Вход:
```c++
1 2 3 6 5 4
```
Изход:
```c++
2 4 6 5 3 1
```


**10.** Иванчо и Марийка решили да вдигнат купон. Марийка викнала само момичета, а Иванчо - само момчета. Тъй като момчетата и момичетата били равен брой, двамата решили да ги подредят по височина и да ги групират по двойки. Да се напише функция, която приема масив от височините на гостите и ги принтира по двойки (момчетата са с нечетна височина, а момичетата - с четна).

**Пример:**

Вход:
```c++
[201, 186, 180, 186, 183, 185, 170, 161, 194, 197, 164, 175, 161, 186]
```
Изход:
```c++
161 164
161 170
175 180
183 186
185 186
197 186
201 194
```

